<!DOCTYPE html>
<!--
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/core/tracks/container_track.html">
<link rel="import" href="/core/tracks/counter_track.html">
<link rel="import" href="/core/tracks/line_plot_track.html">
<link rel="import" href="/core/trace_model/counter.html">
<link rel="import" href="/core/trace_model/counter_series.html">

<script>
'use strict';

tv.exportTo('tv.c.tracks', function() {

  /**
   * A track that displays an array of memoryDump objects.
   * @constructor
   * @extends {ContainerTrack}
   */
  var GlobalMemoryDumpTrack = tv.b.ui.define(
      'global-memory-dump-track', tv.c.tracks.ContainerTrack);

  GlobalMemoryDumpTrack.prototype = {
    __proto__: tv.c.tracks.ContainerTrack.prototype,

    decorate: function(viewport) {
      tv.c.tracks.ContainerTrack.prototype.decorate.call(this, viewport);
      this.memoryDumps_ = undefined;

      this.usedMemoryTrack_ = new tv.c.tracks.CounterTrack(viewport);
      this.usedMemoryTrack_.style.height = '50px';
      this.appendChild(this.usedMemoryTrack_);
      
      this.allocatedMemoryTrack_ = new tv.c.tracks.LinePlotTrack(viewport);
      this.allocatedMemoryTrack_.style.height = '50px';
      this.appendChild(this.allocatedMemoryTrack_);
    },

    get memoryDumps() {
      return this.memoryDumps_;
    },

    set memoryDumps(memoryDumps) {
      this.memoryDumps_ = memoryDumps;

      this.usedMemoryTrack_.counter = buildCounter(memoryDumps);
      this.usedMemoryTrack_.heading = 'Used memory (per process)';

      this.allocatedMemoryTrack_.plots = buildPlots(memoryDumps);
      this.allocatedMemoryTrack_.heading = 'Allocated memory (per allocator)';
    },

    updateContents_: function() {
      this.usedMemoryTrack_.updateContents_();
      this.allocatedMemoryTrack_.updateContents_();
    }
  };

  function buildCounter(globalMemoryDumps) {
    if (globalMemoryDumps === undefined)
      return undefined;

    var instrumentedProcesses = {};
    globalMemoryDumps.forEach(function(globalDump) {
      tv.b.iterItems(globalDump.processMemoryDumps, function(pid, processDump) {
        instrumentedProcesses[pid] = processDump.process;
      });
    });

    var counter = new tv.c.trace_model.Counter(
        undefined, 'global-memory', '', 'Global Memory');

    var pidToSeries = {};
    tv.b.iterItems(instrumentedProcesses, function(pid, process) {
      var series = new tv.c.trace_model.CounterSeries(
          process.userFriendlyName,
          tv.b.ui.getColorIdForGeneralPurposeString(process.userFriendlyName));
      pidToSeries[pid] = series;
      counter.addSeries(series);
    });

    var lastPss = {};

    globalMemoryDumps.forEach(function(globalDump) {
      tv.b.iterItems(pidToSeries, function(pid, series) {
        var processMemoryDump = globalDump.processMemoryDumps[pid];
        var timestamp = globalDump.start;
        var pss = calculatePss(processMemoryDump, lastPss[pid]);
        lastPss[pid] = pss;
        series.addCounterSample(timestamp, pss);
      });
    });

    counter.updateBounds();

    return counter;
  };

  function calculatePss(processMemoryDump, lastPss) {
    if (processMemoryDump === undefined)
      return 0;
    if (processMemoryDump.vmRegions === undefined)
      return lastPss || 0;

    var pss = 0;
    processMemoryDump.vmRegions.forEach(function(vmRegion) {
      pss += vmRegion.byteStats.proportionalResident;
    });
    return pss;
  };

  function buildPlots(globalMemoryDumps) {
    if (globalMemoryDumps === undefined)
      return undefined;

    var instrumentedAllocators = {};
    var instrumentedProcesses = {};
    globalMemoryDumps.forEach(function(globalDump) {
      tv.b.iterItems(globalDump.processMemoryDumps, function(pid, processDump) {
        processDump.memoryAllocatorDumps.forEach(function(allocatorDump) {
          instrumentedAllocators[allocatorDump.fullName] = true;
        });
        instrumentedProcesses[processDump.process.pid] = processDump.process;
      });
    });

    var allocatorToPlots = {};
    var lastValues = {};
    for (var key in instrumentedAllocators) {
      allocatorToPlots[key] = {
        name: key,
        color: tv.b.ui.getColorIdForGeneralPurposeString(key),
        timestamps: [],
        values: []
      };
      lastValues[key] = {};
    }

    globalMemoryDumps.forEach(function(globalMemoryDump) {
      tv.b.iterItems(allocatorToPlots, function(allocatorFullName, plot) {
        var totalPhysicalSize = 0;
        for (var pid in instrumentedProcesses) {
          var processMemoryDump = globalMemoryDump.processMemoryDumps[pid];
          var physicalSize = calculatePhysicalSize(allocatorFullName,
              processMemoryDump, lastValues[allocatorFullName][pid]);
          lastValues[allocatorFullName][pid] = physicalSize;
          totalPhysicalSize += physicalSize;
        }
        plot.timestamps.push(globalMemoryDump.start);
        plot.values.push(totalPhysicalSize);
      });
    })

    var plots = [];
    tv.b.iterItems(allocatorToPlots, function(allocatorFullName, plot) {
      plots.push(plot);
    });

    return plots;
  };

  function calculatePhysicalSize(allocatorFullName, processMemoryDump,
      lastPhysicalSize) {
    if (processMemoryDump === undefined)
      return 0;

    var allocatorDump = undefined;
    for (var i = 0; i < processMemoryDump.memoryAllocatorDumps.length; i++) {
      var d = processMemoryDump.memoryAllocatorDumps[i];
      if (d.fullName === allocatorFullName) {
        allocatorDump = d;
        break;
      }
    }

    if (allocatorDump === undefined)
      return lastPhysicalSize || 0;

    return allocatorDump.physicalSizeInBytes;
  };

  return {
    GlobalMemoryDumpTrack: GlobalMemoryDumpTrack
  };
});
</script>
