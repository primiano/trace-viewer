<!DOCTYPE html>
<!--
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/core/tracks/counter_track.html">
<link rel="import" href="/core/trace_model/counter.html">
<link rel="import" href="/core/trace_model/counter_series.html">

<script>
'use strict';

tv.exportTo('tv.c.tracks', function() {

  /**
   * A track that displays an array of memoryDump objects.
   * @constructor
   * @extends {CounterTrack}
   */
  var GlobalMemoryDumpTrack = tv.b.ui.define(
      'global-memory-dump-track', tv.c.tracks.CounterTrack);

  GlobalMemoryDumpTrack.prototype = {
    __proto__: tv.c.tracks.CounterTrack.prototype,

    decorate: function(viewport) {
      tv.c.tracks.CounterTrack.prototype.decorate.call(this, viewport);
      this.memoryDumps_ = undefined;
    },

    get memoryDumps() {
      return this.memoryDumps_;
    },

    set memoryDumps(memoryDumps) {
      this.memoryDumps_ = memoryDumps;
      this.counter = buildCounter(memoryDumps);
    }
  };

  function buildCounter(globalMemoryDumps) {
    if (globalMemoryDumps === undefined)
      return undefined;

    var instrumentedProcesses = {};
    globalMemoryDumps.forEach(function(globalDump) {
      tv.b.iterItems(globalDump.processMemoryDumps, function(pid, processDump) {
        instrumentedProcesses[pid] = processDump.process;
      });
    });

    var counter = new tv.c.trace_model.Counter(
        undefined, 'global-memory', '', 'Global Memory');

    var pidToSeries = {};
    tv.b.iterItems(instrumentedProcesses, function(pid, process) {
      var series = new tv.c.trace_model.CounterSeries(
          process.userFriendlyName,
          tv.b.ui.getColorIdForGeneralPurposeString(process.userFriendlyName));
      pidToSeries[pid] = series;
      counter.addSeries(series);
    });

    var lastPss = {};

    globalMemoryDumps.forEach(function(globalDump) {
      tv.b.iterItems(pidToSeries, function(pid, series) {
        var processMemoryDump = globalDump.processMemoryDumps[pid];
        var timestamp = globalDump.start;
        var pss = calculatePss(processMemoryDump, lastPss[pid]);
        lastPss[pid] = pss;
        series.addCounterSample(timestamp, pss);
      });
    });

    counter.updateBounds();

    return counter;
  };

  function calculatePss(processMemoryDump, lastPss) {
    if (processMemoryDump === undefined)
      return 0;
    if (processMemoryDump.vmRegions === undefined)
      return lastPss || 0;

    var pss = 0;
    processMemoryDump.vmRegions.forEach(function(vmRegion) {
      pss += vmRegion.byteStats.proportionalResident;
    });
    return pss;
  };

  return {
    GlobalMemoryDumpTrack: GlobalMemoryDumpTrack
  };
});
</script>
