<!DOCTYPE html>
<!--
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/core/tracks/rect_track.html">
<link rel="import" href="/base/ui.html">
<link rel="import" href="/base/ui/color_scheme.html">

<script>
'use strict';

tv.exportTo('tv.c.tracks', function() {
  function compareNumbers(a, b) {
    return a - b;
  }

  /**
   * Visualizes a Process's state using a series of rects to represent activity.
   * @constructor
   */
  var ProcessSummaryTrack = tv.b.ui.define('process-summary-track',
                                           tv.c.tracks.RectTrack);

  ProcessSummaryTrack.buildRectsFromProcess = function(process) {
    if (!process)
      return [];

    // collect top level slices of all threads together
    var starts = [];
    var ends = [];
    for (var tid in process.threads) {
      var thread = process.threads[tid];

      process.threads[tid].sliceGroup.topLevelSlices.forEach(function(slice) {
        starts.push(slice.start);
        ends.push(slice.end);
      });
    }

    // sort starts and ends so they're all ordered in global time
    starts.sort(compareNumbers);
    ends.sort(compareNumbers);

    // 'merge sort' the starts/ends to find depth at any given time
    // creates rect between each rising and falling edge of that depth
    var colorId = tv.b.ui.getColorIdForReservedName('generic_work');
    var lastStart = undefined;
    var startIndex = 0;
    var endIndex = 0;
    var depth = 0;
    var rects = [];
    while (startIndex < starts.length || endIndex < ends.length) {
      if (startIndex < starts.length && starts[startIndex] <= ends[endIndex]) {
        if (depth == 0) {
          // rising edge, start a rect
          lastStart = starts[startIndex];
        }
        startIndex++;
        depth++;
      } else {
        if (depth == 1) {
          // falling edge, end a rect
          rects.push({
            start: lastStart,
            end: ends[endIndex],
            duration: ends[endIndex] - lastStart,
            colorId: colorId
          });
        }
        endIndex++;
        depth--;
      }
    }

    return rects;
  };

  ProcessSummaryTrack.prototype = {
    __proto__: tv.c.tracks.RectTrack.prototype,

    decorate: function(viewport) {
      tv.c.tracks.RectTrack.prototype.decorate.call(this, viewport);
      this.classList.add('inverse-expand');
    },

    get process() {
      return this.process_;
    },

    set process(process) {
      this.process_ = process;
      this.rects = ProcessSummaryTrack.buildRectsFromProcess(process);
    },

    getModelEventFromItem: function(thing) {
      // Do nothing, since not selectable
      return undefined;
    }
  };

  return {
    ProcessSummaryTrack: ProcessSummaryTrack
  };
});
</script>
